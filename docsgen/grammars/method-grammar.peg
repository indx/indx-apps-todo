@import "utils-grammar.peg"

start
	= ps:properties d:description_lines
			{ return { properties: ps, description: d }; }

property
	= a:argument
			{ return ['args', a]; }
	/ r:result
			{ return ['result', r]; }
	/ "@" k:name _ v:comment?
			{ return [k, v || true]; }

argument
	= m:argument_mode _ t:type_statement? _ n:name _ ":"? _ c:comment?
			{ return { mode: m, types: t, name: n, comment: c }; }

argument_mode
	= "@arg"
		{ return { mandatory: true }; }
	/ "@opt"
		{ return { optional: true }; }

result
	= r:return_result
			{ return { "return": r }; }
    / r:async_result
			{ return { "async": r }; }
    / "@chain"
			{ return { "chain": true }; }

return_result
	= "@return" _ t:type_statement? _ c:comment
			{ return { comment: c, types: t }; }

async_result
	= c:async_result_case cs:async_result
			{	var a = c[0] === 'fail' ? cs['fails'] : cs['thens'];
				a.push(c[1]);
				return cs; }
	/ c:async_result_case
			{	var cs = { thens: [], fails: [] },
					a = c[0] === 'fail' ? cs['fails'] : cs['thens'];
				a.push(c[1]);
				return cs; }

async_result_case
	= m:async_result_case_mode _ cb:callback? _ c:comment
			{ return [m, { comment: c, args: cb }]; }


async_result_case_mode
	= "@then"
			{ return 'then'; }
	/ "@fail"
			{ return 'fail'; }

callback
	= _ "(" _ c:callback_arguments _ ")" _
			{ return c; }

callback_arguments
	= _ c:callback_argument _ "," _ cs:callback_arguments _
			{ return [].concat(cs, [c]); }
	/ _ c:callback_argument _
			{ return [c]; }

callback_argument
	= _ t:type_statement _ c:callback_argument_comment  _
			{ return { type: t, comment: c }; }

callback_argument_comment
	= c:[^\n\r),]*
			{ return c.join(''); }

type_statement
	= _ "<" _ ts:types _ ">" _
			{ return ts; }

types
	= _ t:type _ "|" _ ts:types _
			{ return [].concat(ts, [t]); }
	/ _ t:type _
			{ return [t]; }

type
	= t: [^|>]+
			{ return { type: t.join('') }; }
